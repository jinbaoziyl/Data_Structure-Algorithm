# 递归、回溯
## 1.递归
递归的基本性质：函数调用本身
把大规模的问题不断变小，再进行推导的过程

递归是自顶向下的算法，动态规划是典型的自底向上的算法

递归写法结构总结：
```
function fn(n)
{
    //第一步：判断输入或者状态是否非法？
    if(input/state is invalid)
    {
        return;
    }

    //第二部: 判断递归是否应当结束？
    if(match condition)
    {
        return some value;
    }

    //第三部: 缩小问题规模
    result1 = fn(n1)
    result2 = fn(n2)
    ...

    //第四部: 整合结果
    return combine(result1, result2)
}

```

2种递归算法解决时间复杂度分析:
迭代法
公式法:
当递归函数的时间执行函数满足:
    T(n) = a*T(n/b) + f(n)   f(n)值每次递归完毕后，额外的计算执行时间
当参数a,b都确定时，只看递归部分，时间复杂度就是: O(n^log(b,a))
公式法-需要牢记3种情况:
情况1： 当递归部分执行时间O(n^log(b,a)) > f(n), 最终时间复杂度O(n^log(b,a))
情况2： 当递归部分执行时间O(n^log(b,a)) < f(n), 最终时间复杂度f(n)
情况3： 当递归部分执行时间O(n^log(b,a)) = f(n), 最终时间复杂度O(n^log(b,a))*logn

例子一: 归并排序
递归的时间执行函数:
    T(n) = 2*T(n/2) + n
    a = 2, b = 2, f(n) = n
    log(b,a) = 1, n^1 = 1
因此符合第三种情况，最终时间复杂度: O(nlogn)

经典问题: 
1. 汉诺塔
2. 归并排序、快速排序
3. Leetcode 91.解码方法
4. Leetcode 247.中心对称数II

快排思想衍生的问题
4. 数组中最小/最大的k个数
5. 数组中出现次数超过一半的数字
6. 无序数组中的中位数
7. 数字在排序数组中出现的次数

树的递归相关问题
8. 二叉树的深度
9. 二叉树定义和三种遍历

10. 字符串的排列

## 2.回溯
回溯: 利用递归的性质
从问题的起始点出发，不断尝试
返回一步甚至多步在做选择，直到抵达终点的过程

回溯算法的精华:
出现非法的情况时，可退到之前的情景，可返回一步或者多步
再去尝试的路径和办法
想要采用回溯算法，就必须保证: 每次都有多种尝试可能

回溯算法结构总结:
```
function fn(n)
{
    //第一步：判断输入或者状态是否非法？
    if(input/state is invalid)
    {
        return;
    }

    //第二步: 判断递归是否应当结束？如果是，就将当前结果保存起来并返回
    if(match condition)
    {
        return some value;
    }

    //遍历所有可能出现的情况
    for( all possible cases)
    {
        //第三步: 尝试下一步的可能性
        solution.push(case)
        //递归
        result = fn(m)
        //第四部: 回溯到上一步
        solution.pop(case)
    }
}

```

经典问题: 
1. Leetcode 39.组合总和
2. Leetcode 52.N皇后II
