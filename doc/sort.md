# 1.0 排序算法
## 1.1 基本的排序算法
### 1.1.1 冒泡排序 / Bubble Sort
冒泡排序的算法思想:
    每一轮，从杂乱无章的数组头部开始，每两个元素比较大小并进行交换；
直到这一轮中最大或者最小的元素放置到数组的尾部；然后，不断地重复这个过程，直到所有元素都排好位置。
Tips: 每一轮中如果没有发生交换，则说明数组已经排好序

空间复杂度: O(1)
假设数组的元素个数是n，这个排序的过程中，直接在给定的数组中进行元素两两交换

时间复杂度: O(n^2)
情况1：给定的数组已经排序
只需要进行n-1次的比较，两两交换次数0，时间复杂度O(n),最好情况
情况2: 给定数组逆序
需要进行n*(n-1)/2次比较，时间复杂度O(n^2),最坏情况
情况2: 给定数组杂乱无章
平均时间复杂度O(n^2)

冒泡排序是一种稳定的排序

### 1.1.2 插入排序 / Insertion Sort
与冒泡排序对比:
在冒泡排序中，每一轮的排序处理后，数组后端的数是排好序的；
在插入排序中，每一轮的排序处理后，数组前端的数是排好序的。

插入排序的思想：
不断地将尚未排好序的数插入到已经排好序的部分

空间复杂度: O(1)
假设数组的元素个数是n，这个排序的过程中，直接在给定的数组中进行元素两两交换

时间复杂度: O(n^2)
情况1：给定的数组已经排序
只需要进行n-1次的比较，两两交换次数0，时间复杂度O(n),最好情况
情况2: 给定数组逆序
需要进行n*(n-1)/2次比较，时间复杂度O(n^2),最坏情况
情况2: 给定数组杂乱无章
平均时间复杂度O(n^2)

插入排序是一种稳定的排序

LeetCode147题是要求对一个链表进行插入排序，可以用来练习

## 1.2 常考的排序算法
### 1.2.1 归并排序 / Merge Sort
分治的思想:
归并排序的核心思想是分治， 把一个复杂问题拆分成若干个子问题来求解
归并的算法思想:
把数组从中间分成两个子数组；一直递归把子数组划分成更小的子数组，直到子数组只有一个元素

时间复杂度: T(n)
归并算法是一个不断递归的过程，假设数组元素的个数n
根据递归的公式化求时间复杂度: T(n) = 2*T(n/2) + O(n),
其中，合并的复杂度O(n), 需要比较n次

怎么解这个公式？
对于规模为n的问题， 一共需要进行log(n)层的大小切分
每一层的合并复杂度O(n)
所以整体的复杂度O(nlogn)

空间复杂度: O(n)
由于合并n个元素需要分配一个大小为n的额外数组，合并之后，这个数组的空间会被释放

归并排序是稳定的排序算法
### 1.2.2 快速排序 / Quick Sort
快速排序的算法思想:
快速排序也采用了分治的思想
把原始的数组筛选成较小和较大的两个子数组，然后递归排序两个子数组;
在划分较大、较小数组时， 如何选定一个基准值尤为关键

时间复杂度:
根据递归的公式化求时间复杂度: T(n) = 2*T(n/2) + O(n),
把规模大小为n的问题分解成n/2的两个子问题；
和基准值进行n-1次比较，所以n-1次比较的复杂度O(n)
所以整体的复杂度O(nlogn)

空间复杂度: O(logn)
和归并排序不同，快速在每次递归过程中，
只需要开辟O(1)的存储空间来完成交换操作；
而递归次数为logn，所以整体的空间复杂度完全取决于压堆栈的次数

### 1.2.3 拓扑排序 / Topological Sort
应用场合
拓扑排序就是要将图论里顶点按照相连的性质进行排序

前提
必须是有向图
图里没有环: 无论从那个顶点出发 都不会回到该顶点
一般用来厘清有依赖关系的任务

运用Bfs实现拓扑排序:
```
void sort()
{
    Queue<Integer> q = new LinkedList();
    //将入度为0的点，加入队列
    for(int v; v < V; v++)
    {
        if(indegree[v] == 0) q.add(v);
    }
    //不断循环直到队列为空
    while(!q.empty())
    {
        //取出待处理点
        int v = q.poll();
        print(v);

        //与处理的点连接的顶点，入度减一
        for(int u = 0; u < adj[v].length; u++)
        {
            if(--indegree[u] == 0)
                q.add(u);
        }
    }
}
```

用DFS实现拓扑排序，也是ok的，不过需要注意关键点:
1. visted集合： 用来纪录已访问过的顶点
2. stack堆栈: 从某顶点出发，访问完其他顶点，最后才把当前的顶点放到堆栈中
3. loop集合： 有效防止有向图中出现环的情况
参考高频题-火星字典

## 1.3 其他排序算法
### 1.3.1 堆排序 / Heap Sort
### 1.3.2 桶排序 / Bucket Sort